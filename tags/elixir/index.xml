<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>elixir on kw7oe</title>
    <link>https://kaiwern.com/tags/elixir/</link>
    <description>Recent content in elixir on kw7oe</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 04 Apr 2022 20:32:56 +0800</lastBuildDate><atom:link href="https://kaiwern.com/tags/elixir/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Writing a mini Redis server in Elixir</title>
      <link>https://kaiwern.com/posts/2022/04/04/writing-a-mini-redis-server-in-elixir/</link>
      <pubDate>Mon, 04 Apr 2022 20:32:56 +0800</pubDate>
      
      <guid>https://kaiwern.com/posts/2022/04/04/writing-a-mini-redis-server-in-elixir/</guid>
      <description>In the previous post, we wrote a simple Redis Protocol specification (RESP) parser. That&amp;rsquo;s just a small part towards to build a mini Redis. Let&amp;rsquo;s continue writing the other parts needed for our mini Redis server.
Here&amp;rsquo;s how the overall architecture looks like:
Redis CLI &amp;lt;-&amp;gt; Redis Server (TCP) &amp;lt;-&amp;gt; RESP Parser â†“ Key Value Store We will use redis-cli as the Redis client and write the following parts:</description>
    </item>
    
    <item>
      <title>Writing a simple Redis Protocol parser in Elixir</title>
      <link>https://kaiwern.com/posts/2022/01/04/writing-a-simple-redis-protocol-parser-in-elixir/</link>
      <pubDate>Tue, 04 Jan 2022 21:01:05 +0800</pubDate>
      
      <guid>https://kaiwern.com/posts/2022/01/04/writing-a-simple-redis-protocol-parser-in-elixir/</guid>
      <description>Today, we are going to write a parser that parse Redis Protocol in Elixir.
There are tons of supported commands in Redis. Since this is our first attempt on implementing it, we will only be focusing on the GET and SET.
At the end of this post, you should be able to write a simple parser to parse request/response by Redis client/server.</description>
    </item>
    
    <item>
      <title>Debugging with tracing in Elixir with recon_trace</title>
      <link>https://kaiwern.com/posts/2021/06/27/debugging-with-tracing-in-elixir-with-recon_trace/</link>
      <pubDate>Sun, 27 Jun 2021 18:42:02 +0800</pubDate>
      
      <guid>https://kaiwern.com/posts/2021/06/27/debugging-with-tracing-in-elixir-with-recon_trace/</guid>
      <description>In my previous blog post, Debugging with Tracing in Elixir, I mentioned about using recon_trace from recon to trace your function calls in your live system.
After using recon_trace a few times and always needing to going back to the documentation to figure out how to use it correctly, I decided to write this post to document the common usage I came across.</description>
    </item>
    
    <item>
      <title>Blue Green Deployment with Nginx for Elixir/Phoenix Release</title>
      <link>https://kaiwern.com/posts/2021/05/15/blue-green-deployment-with-nginx-for-elixir-phoenix-release/</link>
      <pubDate>Sat, 15 May 2021 19:30:41 +0800</pubDate>
      
      <guid>https://kaiwern.com/posts/2021/05/15/blue-green-deployment-with-nginx-for-elixir-phoenix-release/</guid>
      <description>In this post today, I&amp;rsquo;ll share about how I setup blue green deployment for my Phoenix application using nginx running on a single machine. This post is made possible thanks to this article about Custom Blue Green Deployment with Nginx And Gitlab CI.
The core idea to make blue green deployment possible for Elixir releases with nginx is through:</description>
    </item>
    
    <item>
      <title>Debugging With Tracing in Elixir</title>
      <link>https://kaiwern.com/posts/2020/11/02/debugging-with-tracing-in-elixir/</link>
      <pubDate>Mon, 02 Nov 2020 20:45:48 +0800</pubDate>
      
      <guid>https://kaiwern.com/posts/2020/11/02/debugging-with-tracing-in-elixir/</guid>
      <description>If you are a video person, and have 24 minutes to spend with, just jump over to this ElixirConf 2020 - Debugging Live Systems on the BEAM talk by Jeffery Utter.
This article is a downgraded version of the video ðŸ˜‚.
I wrote this before the video is published. Then, I came across it and learn a lot more from there.</description>
    </item>
    
    <item>
      <title>Deploying Elixir/Phoenix Release to Production</title>
      <link>https://kaiwern.com/posts/2020/07/20/deploying-elixir/phoenix-release-to-production/</link>
      <pubDate>Mon, 20 Jul 2020 20:09:01 +0800</pubDate>
      
      <guid>https://kaiwern.com/posts/2020/07/20/deploying-elixir/phoenix-release-to-production/</guid>
      <description>Updates (12th August 2020): Fix my mistake on using bin/app restart.
Updates (7th October 2020): Include the reason why bin/app restart doesn&amp;rsquo;t work
In my previous post &amp;ldquo;Building Elixir/Phoenix Release With Docker&amp;rdquo;, I wrote about how I build Elixir release with Docker and extract the tarball. Today, I am going to share how I deploy Elixir release to the production server.</description>
    </item>
    
    <item>
      <title>Building Elixir/Phoenix Release With Docker</title>
      <link>https://kaiwern.com/posts/2020/06/20/building-elixir/phoenix-release-with-docker/</link>
      <pubDate>Sat, 20 Jun 2020 14:17:08 +0800</pubDate>
      
      <guid>https://kaiwern.com/posts/2020/06/20/building-elixir/phoenix-release-with-docker/</guid>
      <description>This is a short post about how I build my Elixir/Phoenix releases with Docker and extract the tarball that will be deployed to production. In this approach, we are just building the release with Docker. We are not building the image to run our application in a Docker container.
This post assume that you have the basic knowledge of Docker, building Elixir release and using Elixir 1.</description>
    </item>
    
    <item>
      <title>What you might want to know about GenServer</title>
      <link>https://kaiwern.com/posts/2020/05/21/what-you-might-want-to-know-about-genserver/</link>
      <pubDate>Thu, 21 May 2020 19:21:59 +0800</pubDate>
      
      <guid>https://kaiwern.com/posts/2020/05/21/what-you-might-want-to-know-about-genserver/</guid>
      <description>I once gave a talk about GenServer in a local Elixir meet up in 2019. To prepare for the talk, I have done a lot of research and readings. With additional experience working with GenServer in a production environment, I have come to realize that there are a lot of caveats when using GenServer.</description>
    </item>
    
    <item>
      <title>Using Tesseract OCR in Elixir/Phoenix</title>
      <link>https://kaiwern.com/posts/2019/06/03/using-tesseract-ocr-in-elixir/phoenix/</link>
      <pubDate>Mon, 03 Jun 2019 18:04:00 +0800</pubDate>
      
      <guid>https://kaiwern.com/posts/2019/06/03/using-tesseract-ocr-in-elixir/phoenix/</guid>
      <description>Lately, I am exploring the use of OCR in Expendere (my expense tracking application) and came across Tesseract OCR.
At the time of writing this blog post, there is no native binding of Tesseract OCR in Elixir. However, there are two Elixir wrapper available on GitHub:
 tesseract-ocr-elixir tesseract-elixir  Both wrapper use System.</description>
    </item>
    
    <item>
      <title>Advent of Code 2018: Day 1 Part 2, How I improve my solution by 34x faster</title>
      <link>https://kaiwern.com/posts/2018/12/01/advent-of-code-2018-day-1-part-2-how-i-improve-my-solution-by-34x-faster/</link>
      <pubDate>Sat, 01 Dec 2018 22:10:00 +0800</pubDate>
      
      <guid>https://kaiwern.com/posts/2018/12/01/advent-of-code-2018-day-1-part-2-how-i-improve-my-solution-by-34x-faster/</guid>
      <description>In the previous post, we had briefly discuss about the solution of Part 1. It is fairly straightforward. I thought Part 2 is going to be easy too. But man, I was wrong. It is a bit tricky.
My initial solution takes around 17 seconds to compute the answer. I made it 34x faster by changing the data structure.</description>
    </item>
    
    <item>
      <title>Advent of Code 2018: Day 1 Part 1</title>
      <link>https://kaiwern.com/posts/2018/12/01/advent-of-code-2018-day-1-part-1/</link>
      <pubDate>Sat, 01 Dec 2018 21:47:00 +0800</pubDate>
      
      <guid>https://kaiwern.com/posts/2018/12/01/advent-of-code-2018-day-1-part-1/</guid>
      <description>Advent of Code (AOC) 2018 has finally arrived. This is the first time I participate in AOC. Last year, when I first heard of AOC, I wanted to participate in it. But due to heavy workload from university, I just give up on doing it.
This year, it&amp;rsquo;s different, I had graduated and working remotely.</description>
    </item>
    
    <item>
      <title>Minimal Elixir Web Application with Plug and Cowboy</title>
      <link>https://kaiwern.com/posts/2018/10/14/minimal-elixir-web-application-with-plug-and-cowboy/</link>
      <pubDate>Sun, 14 Oct 2018 15:32:00 +0800</pubDate>
      
      <guid>https://kaiwern.com/posts/2018/10/14/minimal-elixir-web-application-with-plug-and-cowboy/</guid>
      <description>It is interesting to learn things from scratch. Coming from Ruby background, I was curious what is the equivalent of Sinatra in Elixir. It&amp;rsquo;s called Plug. It is what Phoenix build on top of.
Using Sinatra, we can write a quick and simple web server with the following code:
require &amp;#39;sinatra&amp;#39; require &amp;#39;json&amp;#39; get &amp;#39;/&amp;#39; do content_type :json JSON({message: &amp;#34;Hello World&amp;#34;}) end How can we achive that in Elixir?</description>
    </item>
    
  </channel>
</rss>
